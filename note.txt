Netty使用场景有很多
1. 作为rpc通信的框架 基于socket
2. 作为长连接的服务器 websocket ,客户端，服务端
   websocket html5的组成部分 可以实现客户端浏览器 与服务器持续的连接
   建立连接好后 通常情况下连接会一直保持 不仅客户端向服务端请求响应 且服务端也可以向
   客户端推送数据 这个在http1.0 1.1是不可能实现的 只能轮询 空轮询
   对于实际的业务来说 很多时候 头信息没意义的 对于长连接来说 他们可以仅仅传递数据本身

3. 作为http应用服务器 比如tomcat jetty这样的 但是不会遵循servlet这样的规范
   有自己的处理方式

4. 支持自定义协议 请求头 内容长度 分隔符等等 netty就会编解码

编写netty服务总结:
  1.定义事件循环组
  2.编写服务启动类，并添加Initializer 在Initializer里面添加handler包含自定义的
    在 handler 里面实现 netty为我们提供的回调方法
  3.绑定端口启动服务

  http 基于无状态的请求响应
  无状态:是指两次请求是没有关联的 服务端不会认为第二次请求是同一个客户端发过来的
  缺点:没法追踪某一个请求是来自哪一个客户端  才有了 cookie session

  请求响应:http的请求的发起方一定是 浏览器 ，服务器给出响应之前一定要建立好连接
  客户端发送请求数据  服务端收到后就做处理完毕后
  就会构造respose对象返回给客户端 若基于http1.0 当返回后 连接就留断掉了
 再次请求会重新建立一个连接

  基于http1.1 的话有了keepAlived 保持持续连接
  客户端向服务端 发送完数据后 服务端会在 一定时间内保持这个连接
  在其时间范围内 再次发送请求 会重用这个连接
  若过了那段时间后 保持的连接就断开了
  再次请求会重新建立一个连接
rmi: remote method invocation 远程方法调用 只针对java 比如ejb
A机器 调用 B那台机器上的方法
字节码的转换传输  ,接收

client：序列化请求 反序列化结果 stub 桩
server：反序列化请求 序列化结果 skeleton 骨架

序列化与反序列化 也叫作 编码与解码

RPC: remote procedure call 远程过调用
很多rpc框架是跨语言的
1.定义一个接口说明文件 描述了对象，对象成员、接口方法等一系列信息
2.通过rpc框架提供的编译器 将接口说明文件编译成具体语言文件
3.在客户端与服务端分别引入rpc编译器所生成的文件 即可像调用本地方法一样去调用远程方法
4.






