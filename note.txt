Netty使用场景有很多
1. 作为rpc通信的框架 基于socket
2. 作为长连接的服务器 websocket ,客户端，服务端
   websocket html5的组成部分 可以实现客户端浏览器 与服务器持续的连接
   建立连接好后 通常情况下连接会一直保持 不仅客户端向服务端请求响应 且服务端也可以向
   客户端推送数据 这个在http1.0 1.1是不可能实现的 只能轮询 空轮询
   对于实际的业务来说 很多时候 头信息没意义的 对于长连接来说 他们可以仅仅传递数据本身

3. 作为http应用服务器 比如tomcat jetty这样的 但是不会遵循servlet这样的规范
   有自己的处理方式

4. 支持自定义协议 请求头 内容长度 分隔符等等 netty就会编解码

编写netty服务总结:
  1.定义事件循环组
  2.编写服务启动类，并添加Initializer 在Initializer里面添加handler包含自定义的
    在 handler 里面实现 netty为我们提供的回调方法
  3.绑定端口启动服务

  http 基于无状态的请求响应
  无状态:是指两次请求是没有关联的 服务端不会认为第二次请求是同一个客户端发过来的
  缺点:没法追踪某一个请求是来自哪一个客户端  才有了 cookie session

  请求响应:http的请求的发起方一定是 浏览器 ，服务器给出响应之前一定要建立好连接
  客户端发送请求数据  服务端收到后就做处理完毕后
  就会构造respose对象返回给客户端 若基于http1.0 当返回后 连接就留断掉了
 再次请求会重新建立一个连接

  基于http1.1 的话有了keepAlived 保持持续连接
  客户端向服务端 发送完数据后 服务端会在 一定时间内保持这个连接
  在其时间范围内 再次发送请求 会重用这个连接
  若过了那段时间后 保持的连接就断开了
  再次请求会重新建立一个连接
rmi: remote method invocation 远程方法调用 只针对java 比如ejb
A机器 调用 B那台机器上的方法
字节码的转换传输  ,接收

client：序列化请求 反序列化结果 stub 桩
server：反序列化请求 序列化结果 skeleton 骨架

序列化与反序列化 也叫作 编码与解码

RPC: remote procedure call 远程过调用
很多rpc框架是跨语言的
1.定义一个接口说明文件 描述了对象，对象成员、接口方法等一系列信息
2.通过rpc框架提供的编译器 将接口说明文件编译成具体语言文件
3.在客户端与服务端分别引入rpc编译器所生成的文件 即可像调用本地方法一样去调用远程方法

java.io中核心的一个概念就是stream 一个流要么是输入流 要么是输出流不可能既可以是输入流又是输出流

java.nio中有3个核心概念：selector（选择器）, channel(通道),buffer(缓冲区)
java.nio中 我们是面向块（block）或是面向缓冲区


可以将nio中的channel 理解成io中的stream
buffer本身实现就是一块内存 底层是个数组,数据的读取、写都是通过buffer来实现的.

但是 nio 不但可以作为输入还可以做为输出 两个职责

将数据从channel读到buffer中 buffer就相当于一个桶 源源不断将数据从channel （河流）捞上来
再读取buffer内的数据到我们的程序中

io可以直接从流中读取到程序中

除了数组之外buffer还提供了对于数据的结构化访问方式  且可以追踪到系统的读写过程
java中的7种原生数据类型都有对应的buffer类型 比如IntBuffer CharBuffer ...  并没有 Boolbuffer这种类型


Channel指的是可以向其写入数据或是从中读取数据的对象 它类似于java中的stream

但是要明确一点就是向channel写入或是读取一定要通过buffer来的

所有数据的读写都是通过buffer来进行的，
永远不会出现直接向channel写入数据的情况 或者直接从chanel读取数据的情况

与stream不同的是 channel是双向的 一个流只可能是in或者out ，
channel打开后则可以进行读取 写入 或读写

由于channel是双向的因此 能够好的反映出 底层os 的真是情况

比如 在linux中 底层os的通道是双向的。

NIO中的3个重要状态属性的含义  position limit capacity

limit,capacity都是最后一个元素的下一个元素
position 下一个将被读写的元素
0 <= mark <= position <= limit <= capacity

通过nio读取文件涉及3个步骤

1.从fileInputSteam中获取到FileCHannel对象
2.创建 buffer
3、将数据从channel读取到buffer中

绝对方法与相对方法的含义

1.相对方法 limit值与pos 值会在操作时候会被考虑到
2.绝对方法 完全忽略limit值与pos的值

    java DirectByteBuffer 堆上 address专门引用堆外内存的地址 从而找到数据

     对它进行操作的
----------------------------------------------------


        数据(一定被堆上的对象所引用)

    native  堆外内存 (通过c或c++ malloc方法)


直接内存缓冲的释放 由jvm控制 找到address 然后释放


间接内存缓冲 是 把程序里 堆上的数据

拷贝到 os 的内存里面 在和io设备交流完毕
再拷贝回去

释放由 os 自动释放


内存映射文件 对内存做的任何修改都会体现在磁盘上
同样也是利用堆外内存

selector channel buffer

Reactor模式
传统的socket存在的问题
多个Thread线程管理多个socket
但是
1、系统上能开的线程是有限的
2、线程一旦多了起来 存在上下文切换的,需要更多的成本
3、因为每个线程有一个socket与之对应,那么socket是用来传递数据的,但可能连接建立好后
在一段时间内可能就没有数据产生了,那么socket还保持着，服务端的线程还存活
那么就造成服务端有大量线程存在 但是每个线程可能没事可做.
Reactor模式的角色构成： Reactor模式共有5个角色

1.handle(句柄或者描述符):本质代表一种资源,是由操作系统提供的 该资源表示一个个事件 比如说文件描述符 针对网络编程中Socket
描述符 。事件既可以来自外部 也可来自内部 。外部事件比如说客户端的连接请求 客户端发送过来数据等，内部
事件比如说os产生的定时器时间等 他本质上就是一个文件描述符。可以说handle本身是事件本身的发源地.
Synchronous Event Demultiplexer(同步事件分离器) 它本身是一个系统调用 用于等待时间的发生（事件可能是一个 也可能是多个） 调用方在调用它的时候会被阻塞 一直阻塞到同步事件分离器上有事件产生为止.这个时候才会返回,对于linux来说 同步事件分离器指的就是常用的I/O多路复用的机制比如select poll epoll等
在java nio领域中 它对应的组件就是selector 对应的阻塞方法就是select方法

3.Event Handler(事件处理器):本身由多个回调方法构成 这些回调方法构成了与应用相关的对于某个事件的反馈机制。
netty相比较nio来说 在事件处理器这个角色上就行了一个升级 它为我们开发者提供了大量的回调方法来进行业务员逻辑的处理
4、Concrete Event Handler(具体事件处理器):它是事件处理器的实现,它本身实现了事件处理器所提供的各个回调方法
从而实现了特定于业务的逻辑 它本质就是我们所编写的一个处理器实现 MyserverHandler ,它继承了SimpleChannelHandler


