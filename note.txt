Netty使用场景有很多
1. 作为rpc通信的框架 基于socket
2. 作为长连接的服务器 websocket ,客户端，服务端
   websocket html5的组成部分 可以实现客户端浏览器 与服务器持续的连接
   建立连接好后 通常情况下连接会一直保持 不仅客户端向服务端请求响应 且服务端也可以向
   客户端推送数据 这个在http1.0 1.1是不可能实现的 只能轮询 空轮询
   对于实际的业务来说 很多时候 头信息没意义的 对于长连接来说 他们可以仅仅传递数据本身

3. 作为http应用服务器 比如tomcat jetty这样的 但是不会遵循servlet这样的规范
   有自己的处理方式

4. 支持自定义协议 请求头 内容长度 分隔符等等 netty就会编解码

编写netty服务总结:
  1.定义事件循环组
  2.编写服务启动类，并添加Initializer 在Initializer里面添加handler包含自定义的
    在 handler 里面实现 netty为我们提供的回调方法
  3.绑定端口启动服务

  http 基于无状态的请求响应
  无状态:是指两次请求是没有关联的 服务端不会认为第二次请求是同一个客户端发过来的
  缺点:没法追踪某一个请求是来自哪一个客户端  才有了 cookie session

  请求响应:http的请求的发起方一定是 浏览器 ，服务器给出响应之前一定要建立好连接
  客户端发送请求数据  服务端收到后就做处理完毕后
  就会构造respose对象返回给客户端 若基于http1.0 当返回后 连接就留断掉了
 再次请求会重新建立一个连接

  基于http1.1 的话有了keepAlived 保持持续连接
  客户端向服务端 发送完数据后 服务端会在 一定时间内保持这个连接
  在其时间范围内 再次发送请求 会重用这个连接
  若过了那段时间后 保持的连接就断开了
  再次请求会重新建立一个连接
rmi: remote method invocation 远程方法调用 只针对java 比如ejb
A机器 调用 B那台机器上的方法
字节码的转换传输  ,接收

client：序列化请求 反序列化结果 stub 桩
server：反序列化请求 序列化结果 skeleton 骨架

序列化与反序列化 也叫作 编码与解码

RPC: remote procedure call 远程过调用
很多rpc框架是跨语言的
1.定义一个接口说明文件 描述了对象，对象成员、接口方法等一系列信息
2.通过rpc框架提供的编译器 将接口说明文件编译成具体语言文件
3.在客户端与服务端分别引入rpc编译器所生成的文件 即可像调用本地方法一样去调用远程方法

java.io中核心的一个概念就是stream 一个流要么是输入流 要么是输出流不可能既可以是输入流又是输出流

java.nio中有3个核心概念：selector（选择器）, channel(通道),buffer(缓冲区)
java.nio中 我们是面向块（block）或是面向缓冲区


可以将nio中的channel 理解成io中的stream
buffer本身实现就是一块内存 底层是个数组,数据的读取、写都是通过buffer来实现的.

但是 nio 不但可以作为输入还可以做为输出 两个职责

将数据从channel读到buffer中 buffer就相当于一个桶 源源不断将数据从channel （河流）捞上来
再读取buffer内的数据到我们的程序中

io可以直接从流中读取到程序中

除了数组之外buffer还提供了对于数据的结构化访问方式  且可以追踪到系统的读写过程
java中的7种原生数据类型都有对应的buffer类型 比如IntBuffer CharBuffer ...  并没有 Boolbuffer这种类型


Channel指的是可以向其写入数据或是从中读取数据的对象 它类似于java中的stream

但是要明确一点就是向channel写入或是读取一定要通过buffer来的

所有数据的读写都是通过buffer来进行的，
永远不会出现直接向channel写入数据的情况 或者直接从chanel读取数据的情况

与stream不同的是 channel是双向的 一个流只可能是in或者out ，
channel打开后则可以进行读取 写入 或读写

由于channel是双向的因此 能够好的反映出 底层os 的真是情况

比如 在linux中 底层os的通道是双向的。

NIO中的3个重要状态属性的含义  position limit capacity

limit,capacity都是最后一个元素的下一个元素
position 下一个将被读写的元素
0 <= mark <= position <= limit <= capacity

通过nio读取文件涉及3个步骤

1.从fileInputSteam中获取到FileCHannel对象
2.创建 buffer
3、将数据从channel读取到buffer中

绝对方法与相对方法的含义

1.相对方法 limit值与pos 值会在操作时候会被考虑到
2.绝对方法 完全忽略limit值与pos的值

    java DirectByteBuffer 堆上 address专门引用堆外内存的地址 从而找到数据

     对它进行操作的
-----------------------------------------------------


        数据(一定被堆上的对象所引用)

    native  堆外内存 (通过c或c++ malloc方法)


直接内存缓冲的释放 由jvm控制 找到address 然后释放


间接内存缓冲 是 把程序里 堆上的数据

拷贝到 os 的内存里面 在和io设备交流完毕
再拷贝回去

释放由 os 自动释放


内存映射文件 对内存做的任何修改都会体现在磁盘上
同样也是利用堆外内存

selector channel buffer
